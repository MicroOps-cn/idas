// Code generated by radius-dict-gen. DO NOT EDIT.

package rfc5580

import (
	"strconv"

	"layeh.com/radius"
)

const (
	OperatorName_Type                radius.Type = 126
	LocationInformation_Type         radius.Type = 127
	LocationData_Type                radius.Type = 128
	BasicLocationPolicyRules_Type    radius.Type = 129
	ExtendedLocationPolicyRules_Type radius.Type = 130
	LocationCapable_Type             radius.Type = 131
	RequestedLocationInfo_Type       radius.Type = 132
)

func OperatorName_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(OperatorName_Type, a)
	return
}

func OperatorName_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(OperatorName_Type, a)
	return
}

func OperatorName_Get(p *radius.Packet) (value []byte) {
	value, _ = OperatorName_Lookup(p)
	return
}

func OperatorName_GetString(p *radius.Packet) (value string) {
	value, _ = OperatorName_LookupString(p)
	return
}

func OperatorName_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != OperatorName_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func OperatorName_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != OperatorName_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func OperatorName_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(OperatorName_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func OperatorName_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(OperatorName_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func OperatorName_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(OperatorName_Type, a)
	return
}

func OperatorName_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(OperatorName_Type, a)
	return
}

func OperatorName_Del(p *radius.Packet) {
	p.Attributes.Del(OperatorName_Type)
}

func LocationInformation_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(LocationInformation_Type, a)
	return
}

func LocationInformation_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(LocationInformation_Type, a)
	return
}

func LocationInformation_Get(p *radius.Packet) (value []byte) {
	value, _ = LocationInformation_Lookup(p)
	return
}

func LocationInformation_GetString(p *radius.Packet) (value string) {
	value, _ = LocationInformation_LookupString(p)
	return
}

func LocationInformation_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != LocationInformation_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func LocationInformation_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != LocationInformation_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func LocationInformation_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(LocationInformation_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func LocationInformation_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(LocationInformation_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func LocationInformation_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(LocationInformation_Type, a)
	return
}

func LocationInformation_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(LocationInformation_Type, a)
	return
}

func LocationInformation_Del(p *radius.Packet) {
	p.Attributes.Del(LocationInformation_Type)
}

func LocationData_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(LocationData_Type, a)
	return
}

func LocationData_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(LocationData_Type, a)
	return
}

func LocationData_Get(p *radius.Packet) (value []byte) {
	value, _ = LocationData_Lookup(p)
	return
}

func LocationData_GetString(p *radius.Packet) (value string) {
	value, _ = LocationData_LookupString(p)
	return
}

func LocationData_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != LocationData_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func LocationData_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != LocationData_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func LocationData_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(LocationData_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func LocationData_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(LocationData_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func LocationData_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(LocationData_Type, a)
	return
}

func LocationData_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(LocationData_Type, a)
	return
}

func LocationData_Del(p *radius.Packet) {
	p.Attributes.Del(LocationData_Type)
}

func BasicLocationPolicyRules_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(BasicLocationPolicyRules_Type, a)
	return
}

func BasicLocationPolicyRules_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(BasicLocationPolicyRules_Type, a)
	return
}

func BasicLocationPolicyRules_Get(p *radius.Packet) (value []byte) {
	value, _ = BasicLocationPolicyRules_Lookup(p)
	return
}

func BasicLocationPolicyRules_GetString(p *radius.Packet) (value string) {
	value, _ = BasicLocationPolicyRules_LookupString(p)
	return
}

func BasicLocationPolicyRules_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != BasicLocationPolicyRules_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func BasicLocationPolicyRules_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != BasicLocationPolicyRules_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func BasicLocationPolicyRules_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(BasicLocationPolicyRules_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func BasicLocationPolicyRules_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(BasicLocationPolicyRules_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func BasicLocationPolicyRules_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(BasicLocationPolicyRules_Type, a)
	return
}

func BasicLocationPolicyRules_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(BasicLocationPolicyRules_Type, a)
	return
}

func BasicLocationPolicyRules_Del(p *radius.Packet) {
	p.Attributes.Del(BasicLocationPolicyRules_Type)
}

func ExtendedLocationPolicyRules_Add(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Add(ExtendedLocationPolicyRules_Type, a)
	return
}

func ExtendedLocationPolicyRules_AddString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Add(ExtendedLocationPolicyRules_Type, a)
	return
}

func ExtendedLocationPolicyRules_Get(p *radius.Packet) (value []byte) {
	value, _ = ExtendedLocationPolicyRules_Lookup(p)
	return
}

func ExtendedLocationPolicyRules_GetString(p *radius.Packet) (value string) {
	value, _ = ExtendedLocationPolicyRules_LookupString(p)
	return
}

func ExtendedLocationPolicyRules_Gets(p *radius.Packet) (values [][]byte, err error) {
	var i []byte
	for _, avp := range p.Attributes {
		if avp.Type != ExtendedLocationPolicyRules_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.Bytes(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func ExtendedLocationPolicyRules_GetStrings(p *radius.Packet) (values []string, err error) {
	var i string
	for _, avp := range p.Attributes {
		if avp.Type != ExtendedLocationPolicyRules_Type {
			continue
		}
		attr := avp.Attribute
		i = radius.String(attr)
		if err != nil {
			return
		}
		values = append(values, i)
	}
	return
}

func ExtendedLocationPolicyRules_Lookup(p *radius.Packet) (value []byte, err error) {
	a, ok := p.Lookup(ExtendedLocationPolicyRules_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.Bytes(a)
	return
}

func ExtendedLocationPolicyRules_LookupString(p *radius.Packet) (value string, err error) {
	a, ok := p.Lookup(ExtendedLocationPolicyRules_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	value = radius.String(a)
	return
}

func ExtendedLocationPolicyRules_Set(p *radius.Packet, value []byte) (err error) {
	var a radius.Attribute
	a, err = radius.NewBytes(value)
	if err != nil {
		return
	}
	p.Set(ExtendedLocationPolicyRules_Type, a)
	return
}

func ExtendedLocationPolicyRules_SetString(p *radius.Packet, value string) (err error) {
	var a radius.Attribute
	a, err = radius.NewString(value)
	if err != nil {
		return
	}
	p.Set(ExtendedLocationPolicyRules_Type, a)
	return
}

func ExtendedLocationPolicyRules_Del(p *radius.Packet) {
	p.Attributes.Del(ExtendedLocationPolicyRules_Type)
}

type LocationCapable uint32

const (
	LocationCapable_Value_CivicLocation LocationCapable = 1
	LocationCapable_Value_GeoLocation   LocationCapable = 2
	LocationCapable_Value_UsersLocation LocationCapable = 4
	LocationCapable_Value_NASLocation   LocationCapable = 8
)

var LocationCapable_Strings = map[LocationCapable]string{
	LocationCapable_Value_CivicLocation: "Civic-Location",
	LocationCapable_Value_GeoLocation:   "Geo-Location",
	LocationCapable_Value_UsersLocation: "Users-Location",
	LocationCapable_Value_NASLocation:   "NAS-Location",
}

func (a LocationCapable) String() string {
	if str, ok := LocationCapable_Strings[a]; ok {
		return str
	}
	return "LocationCapable(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func LocationCapable_Add(p *radius.Packet, value LocationCapable) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(LocationCapable_Type, a)
	return
}

func LocationCapable_Get(p *radius.Packet) (value LocationCapable) {
	value, _ = LocationCapable_Lookup(p)
	return
}

func LocationCapable_Gets(p *radius.Packet) (values []LocationCapable, err error) {
	var i uint32
	for _, avp := range p.Attributes {
		if avp.Type != LocationCapable_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, LocationCapable(i))
	}
	return
}

func LocationCapable_Lookup(p *radius.Packet) (value LocationCapable, err error) {
	a, ok := p.Lookup(LocationCapable_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = LocationCapable(i)
	return
}

func LocationCapable_Set(p *radius.Packet, value LocationCapable) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(LocationCapable_Type, a)
	return
}

func LocationCapable_Del(p *radius.Packet) {
	p.Attributes.Del(LocationCapable_Type)
}

type RequestedLocationInfo uint32

const (
	RequestedLocationInfo_Value_CivicLocation  RequestedLocationInfo = 1
	RequestedLocationInfo_Value_GeoLocation    RequestedLocationInfo = 2
	RequestedLocationInfo_Value_UsersLocation  RequestedLocationInfo = 4
	RequestedLocationInfo_Value_NASLocation    RequestedLocationInfo = 8
	RequestedLocationInfo_Value_FutureRequests RequestedLocationInfo = 16
	RequestedLocationInfo_Value_None           RequestedLocationInfo = 32
)

var RequestedLocationInfo_Strings = map[RequestedLocationInfo]string{
	RequestedLocationInfo_Value_CivicLocation:  "Civic-Location",
	RequestedLocationInfo_Value_GeoLocation:    "Geo-Location",
	RequestedLocationInfo_Value_UsersLocation:  "Users-Location",
	RequestedLocationInfo_Value_NASLocation:    "NAS-Location",
	RequestedLocationInfo_Value_FutureRequests: "Future-Requests",
	RequestedLocationInfo_Value_None:           "None",
}

func (a RequestedLocationInfo) String() string {
	if str, ok := RequestedLocationInfo_Strings[a]; ok {
		return str
	}
	return "RequestedLocationInfo(" + strconv.FormatUint(uint64(a), 10) + ")"
}

func RequestedLocationInfo_Add(p *radius.Packet, value RequestedLocationInfo) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Add(RequestedLocationInfo_Type, a)
	return
}

func RequestedLocationInfo_Get(p *radius.Packet) (value RequestedLocationInfo) {
	value, _ = RequestedLocationInfo_Lookup(p)
	return
}

func RequestedLocationInfo_Gets(p *radius.Packet) (values []RequestedLocationInfo, err error) {
	var i uint32
	for _, avp := range p.Attributes {
		if avp.Type != RequestedLocationInfo_Type {
			continue
		}
		attr := avp.Attribute
		i, err = radius.Integer(attr)
		if err != nil {
			return
		}
		values = append(values, RequestedLocationInfo(i))
	}
	return
}

func RequestedLocationInfo_Lookup(p *radius.Packet) (value RequestedLocationInfo, err error) {
	a, ok := p.Lookup(RequestedLocationInfo_Type)
	if !ok {
		err = radius.ErrNoAttribute
		return
	}
	var i uint32
	i, err = radius.Integer(a)
	if err != nil {
		return
	}
	value = RequestedLocationInfo(i)
	return
}

func RequestedLocationInfo_Set(p *radius.Packet, value RequestedLocationInfo) (err error) {
	a := radius.NewInteger(uint32(value))
	p.Set(RequestedLocationInfo_Type, a)
	return
}

func RequestedLocationInfo_Del(p *radius.Packet) {
	p.Attributes.Del(RequestedLocationInfo_Type)
}
